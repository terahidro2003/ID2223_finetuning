[
  {
    "role": "system",
    "content": "Provide the best response to a given instruction. Follow the following steps to craft your response:\n1. reason about the given instruction\n2. provide a high-quality solution\n3. offer a concise explanation\n4. write tests to verify the correctness your solution\n\n## Example 1\n### Instruction\nCreate a Python function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n### Response\n[Reasoning]\nTo create such a function, we can use a loop to iterate through a predefined list of units (`['bytes', 'KB', 'MB', 'GB', 'TB']`) and check if the given number of bytes fits into the current unit by comparing it with 1024.0 and -1024.0 (for handling negative sizes). We'll keep dividing the number by 1024.0 until the correct unit is found where the number is less than 1024.0. Then, we'll format the result using the appropriate unit and the rounded size.\n\n[Implementation]\n```python\ndef format_size(size_bytes):\n    units = ['bytes', 'KB', 'MB', 'GB', 'TB']\n    if size_bytes == 0:\n        return \"0.0bytes\"  # Directly return for 0 bytes to avoid division by zero in loop\n    num = abs(size_bytes)\n    unit = units[0]\n\n    for u in units[1:]:\n        if num < 1024.0:\n            break\n        num /= 1024.0\n        unit = u\n\n    formatted_size = f\"{num:.1f}{unit}\"\n    return formatted_size if size_bytes >= 0 else f\"-{formatted_size}\"\n```\n\n[Explanation]\nThis implementation handles both positive and negative file sizes and returns the formatted size as a string, even though negative sizes are not common in real-world scenarios.\n\n[Tests]\nYou can write the following test cases to ensure it works correctly:\n\n```python\ntest_data = [\n    (1024 ** 2, \"1.0MB\"),\n    (1024 ** 2 - 1, \"1024.0KB\"),\n    (1024 ** 3 * 512, \"512.0GB\"),\n    (1024 ** 4 * 512, \"512.0TB\"),\n]\nfor size, expected_output in test_data:\n    assert format_size(size) == expected_output\n    assert format_size(-size) == f\"-{expected_output}\"\n```\n\nThese test cases cover both positive and negative sizes across different units to validate the correctness of the `format_size` function.\n\n## Example 2\n### Instruction\nWrite a Python decorator that counts the number of times a function is called. The decorator should modify the original function in-place to count the call frequency and store it in a dictionary with function names as keys and count as values.\n\nFor example, given the following code:\n```python\n@count_calls\ndef func():\n    return 1\n```\n\nIf the function is called three times:\n```python\nfunc()\nfunc()\nfunc()\n```\n\nThen the decorator should modify the code to:\n```python\nfunc_counts[\"func\"] = 3\n```\n\nFurthermore, when the function is called again, it should update the count to 4:\n```python\nfunc()\n```\n\n### Response"
  },
  {
    "role": "user",
    "content": "Write a Python decorator that counts the number of times a function is called. The decorator should modify the original function in-place to count the call frequency and store it in a dictionary with function names as keys and count as values.\n\nFor example, given the following code:\n```python\n@count_calls\ndef func():\n    return 1\n```\n\nIf the function is called three times:\n```python\nfunc()\nfunc()\nfunc()\n```\n\nThen the decorator should modify the code to:\n```python\nfunc_counts[\"func\"] = 3\n```\n\nFurthermore, when the function is called again, it should update the count to 4:\n```python\nfunc()\n```"
  }
]