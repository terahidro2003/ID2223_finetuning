Step 1:  To solve this problem, we need to find the minimum number of operations required to transform the initial value to the target value, considering the restrictions on the operations that can be performed.
Step 2:  We want to iterate through each test case and perform operations until we either reach the target value or find that reaching the target value is not possible.
Step 3:  We'll need to consider the possible operations based on the current value and the necessary conditions for each operation.
Step 4:  We'll also need to handle cases where it's not possible to reach the target value.
Step 5:  To solve this problem, we'll iterate through the test cases, compute the number of operations required, and output the result accordingly.
```python
# Step 6: 
import sys

# Step 7:  Read the number of test cases as input
t = int(sys.stdin.readline())
# Step 8:  Iterate through each test case
for _ in range(t):
    # Step 9:  Read the initial and target values as input
    
    a, b = list(map(int, sys.stdin.readline().strip().split(' ')))
    # Step 10:  Ensure that the smaller of the two values is designated as 'a' for simplicity
    
    if a > b:
        a, b = b, a
    # Step 11:  Initialize the number of operations needed to transform 'a' into 'b' to 0
    
    ans = 0
    # Step 12:  Iterate through the possible operations until 'a' reaches 'b' or it's determined that reaching 'b' is not possible
    
    while a < b:
        # Step 13:  Check the conditions for multiplication by 8, 4, or 2 and update 'a' accordingly
        
        if a * 8 <= b:
            a *= 8
        elif a * 4 <= b:
            a *= 4
        else:
            a *= 2
        # Step 14:  Increment the number of operations
        
        ans += 1
    # Step 15:  Output the number of operations required to transform 'a' into 'b' (or -1 if reaching 'b' is not possible)
    
    if a != b:
        print(-1)
    else:
        print(ans)

```